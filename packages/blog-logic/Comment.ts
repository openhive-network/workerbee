import { TWaxExtended } from "@hiveio/wax";
import { IBloggingPlatform, IComment, IPagination, IPostCommentIdentity, IVote, IVotesFilters } from "./interfaces";
import { paginateData } from "./utils";
import { Vote } from "./Vote";
import { Entry, ExtendedNodeApi, getWax } from "./wax";

export class Comment implements IComment {

  protected chain?: TWaxExtended<ExtendedNodeApi>

  public author: string;
  public permlink: string;
  public publishedAt: Date;
  public updatedAt: Date;


  protected content?: string;
  protected votes?: Iterable<IVote>;
  protected bloggingPlatform: IBloggingPlatform;


  protected initializeChain = async () => {
    if (!this.chain)
      this.chain = await getWax();
  }

  // Refactor blogginPlatform and data into dataProvider with promises.
  public constructor(authorPermlink: IPostCommentIdentity, bloggingPlatform: IBloggingPlatform, postCommentData: Entry, ) {
    this.initializeChain();
    this.author = authorPermlink.author;
    this.permlink = authorPermlink.permlink;
    this.bloggingPlatform = bloggingPlatform;
    this.publishedAt = new Date(`${postCommentData.created}Z`);
    this.updatedAt = new Date(`${postCommentData.updated}Z`);
    this.content = postCommentData.body;
  }

  /**
   * Create standard slug that can be used in Wordpress. It's generated by adding "_" between author and permlink.
   */
  public getSlug(): string {
    return `${this.author}_${this.permlink}`;
  }

  /**
   * Get list of all mentioned accounts as strings.
   */
  /* eslint-disable-next-line require-await */
  public async enumMentionedAccounts(): Promise<Iterable<string>> {
    const regex = /@[a-z]+[a-z0-9.-]+[a-z0-9]+\b/g; // Alphanumeric with . and -, but not on the end.
    return this.content?.match(regex) ?? [];
  }

  /**
   * Get full body of comment or post.
   */
  /* eslint-disable-next-line require-await */
  public async getContent(): Promise<string> {
    return this.content || ""
  }

  /**
   * Return all votes for given comment.
   * @param filter Standard filters for date and order.
   * @param pagination
   * @returns Iterable of Votes.
   */
  public async enumVotes(filter: IVotesFilters, pagination: IPagination): Promise<Iterable<IVote>> {
    this.initializeChain();
    // Get rid of condenser API
    const votesData = await this.chain!.api.database_api.list_votes({limit: filter.limit, order: filter.votesSort, start: null});
    const votes = votesData.votes.map((vote) => new Vote(vote));
    this.votes = votes;
    return paginateData<IVote>(votes, pagination);
  }

  /**
   * Check if this post was voted by selecred user.
   * @param userName
   */
  public async wasVotedByUser(userName: string): Promise<boolean> {
    this.initializeChain();
    if (!this.votes) await this.enumVotes({limit: 10000, votesSort: "by_comment_voter"}, {page: 1, pageSize: 10000}); // Temporary pagination before fix
    return Array.from(this.votes || []).some((vote) => vote.voter === userName)
  }

}
